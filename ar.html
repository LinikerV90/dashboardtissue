
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AR Motores – Dashboard Tissue</title>

  <!-- A-Frame + MindAR (WebAR image tracking) -->
  https://aframe.io/releases/1.4.2/aframe.min.js</script>
  https://cdn.jsdelivr.net/gh/hiukim/mind-ar-js@1.1.0/dist/mindar-image.prod.js</script>
  https://cdn.jsdelivr.net/gh/hiukim/mind-ar-js@1.1.0/dist/mindar-image-aframe.prod.js</script>

  <!-- Gauges em Canvas -->
  https://cdn.jsdelivr.net/npm/canvas-gauges@2.1.7/gauge.min.js</script>

  <style>
    body { margin:0; overflow:hidden; font-family: Inter, Arial, sans-serif; }
    .arjs-loader {
      height: 100%; width: 100%; position: absolute; top: 0; left: 0;
      background: rgba(0,0,0,0.85); z-index: 9999;
      display:flex; justify-content:center; align-items:center; color:#fff;
    }
    /* Tamanhos dos canvases (texturas dos gauges) */
    canvas { display:none; } /* escondidos na UI; usados como textura */
  </style>
</head>
<body>

  <!-- Loader enquanto carrega targets.mind -->
  <div class="arjs-loader"><div>Carregando AR... aguarde</div></div>

  <!-- Canvases para os gauges (texturas) -->
  <canvas id="gTorque" width="512" height="512"></canvas>
  <canvas id="gCorrente" width="512" height="512"></canvas>
  <canvas id="gTemperatura" width="512" height="512"></canvas>

  <!-- Cena AR -->
  <a-scene
    mindar-image="imageTargetSrc: assets/targets.mind;"
    color-space="sRGB"
    renderer="colorManagement: true, physicallyCorrectLights: true"
    vr-mode-ui="enabled: false"
    device-orientation-permission-ui="enabled: true"
    embedded
  >
    <a-assets>
      <!-- Registra os canvases como assets para usar como textura -->
      <canvas id="texTorque" width="512" height="512"></canvas>
      <canvas id="texCorrente" width="512" height="512"></canvas>
      <canvas id="texTemperatura" width="512" height="512"></canvas>
    </a-assets>

    <!-- Âncora dinâmica: será criada via JS com o targetIndex do motor -->
    <!-- Dentro dela vamos inserir 3 planos com as texturas + o nome do motor -->

    <a-camera position="0 0 0"></a-camera>
  </a-scene>

<script>
(function(){
  // ======= CONFIG =======
  const SHEET_ID   = '1W9OPl0BG72_6t0nGy1kaDqfIICkLgG8YnkD_Y5uCb4k';      // ID da planilha
  const SHEET_NAME = 'SERVOS';        // Nome da aba (ex.: 'Motores')
  // Mapeamento motor -> índice do alvo no targets.mind (0 a N-1)
  // Preencha conforme a ordem que você compilou os QRs:
  const TARGET_INDEX_MAP = {
    'MOTOR_01': 0,
    'MOTOR_02': 1,
    'MOTOR_03': 2,
    // ...
  };

  // ======= UTIL =======
  function getParam(name){
    return new URLSearchParams(location.search).get(name) || '';
  }

  // Parseia o retorno GViz (remove prefixo/sufixo e vira JSON)
  // Técnica comum para endpoint /gviz/tq com out:json. [8](https://basescripts.com/wp-content/uploads/2021/08/Google-Sheet-Data-as-JSON-Guide.pdf)
  async function fetchSheetRow(motorId){
    const tq = `select A,B,C,D where A='${motorId}' limit 1`;
    const url = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?sheet=${encodeURIComponent(SHEET_NAME)}&tqx=out:json&tq=${encodeURIComponent(tq)}`;
    const res = await fetch(url);
    const txt = await res.text();
    const jsonStr = txt.substring(txt.indexOf('{'), txt.lastIndexOf('}') + 1);
    const obj = JSON.parse(jsonStr);
    const row = (obj.table.rows && obj.table.rows[0]) ? obj.table.rows[0].c : null;
    if(!row) throw new Error('Motor não encontrado na planilha.');
    // A: nome, B: torque, C: corrente, D: temperatura
    return {
      nome:        row[0]?.v || motorId,
      torque:      Number(row[1]?.v) || 0,
      corrente:    Number(row[2]?.v) || 0,
      temperatura: Number(row[3]?.v) || 0
    };
  }

  // Cria gauges em cada canvas
  function createGauges(){
    const torqueGauge = new RadialGauge({
      renderTo: 'gTorque',
      width: 512, height: 512,
      units: 'Torque (Nm)',
      minValue: 0, maxValue: 100, // ajuste o range
      majorTicks: ['0','20','40','60','80','100'],
      minorTicks: 4,
      borders: true,
      value: 0,
      highlights: [
        { from: 0,  to: 60, color: '#30B32D' },
        { from: 60, to: 85, color: '#FFDD00' },
        { from: 85, to: 100, color: '#F03E3E' },
      ]
    }).draw();

    const correnteGauge = new RadialGauge({
      renderTo: 'gCorrente',
      width: 512, height: 512,
      units: 'Corrente (A)',
      minValue: 0, maxValue: 100, // ajuste o range
      majorTicks: ['0','20','40','60','80','100'],
      minorTicks: 4,
      borders: true,
      value: 0,
      highlights: [
        { from: 0,  to: 60, color: '#30B32D' },
        { from: 60, to: 85, color: '#FFDD00' },
        { from: 85, to: 100, color: '#F03E3E' },
      ]
    }).draw();

    const temperaturaGauge = new RadialGauge({
      renderTo: 'gTemperatura',
      width: 512, height: 512,
      units: 'Temperatura (°C)',
      minValue: 0, maxValue: 120, // ajuste o range
      majorTicks: ['0','20','40','60','80','100','120'],
      minorTicks: 4,
      borders: true,
      value: 0,
      highlights: [
        { from: 0,   to: 70,  color: '#30B32D' },
        { from: 70,  to: 90,  color: '#FFDD00' },
        { from: 90,  to: 120, color: '#F03E3E' },
      ]
    }).draw();

    return { torqueGauge, correnteGauge, temperaturaGauge };
  }

  // Atualiza valores dos gauges
  function updateGauges(gauges, data){
    gauges.torqueGauge.value      = data.torque;
    gauges.correnteGauge.value    = data.corrente;
    gauges.temperaturaGauge.value = data.temperatura;
    gauges.torqueGauge.draw();
    gauges.correnteGauge.draw();
    gauges.temperaturaGauge.draw();
  }

  // Copia conteúdo dos canvases para assets (se quiser separar)
  function mirrorCanvasesToAssets(){
    ['gTorque','gCorrente','gTemperatura'].forEach((id, i) => {
      const src = document.getElementById(id);
      const dst = document.getElementById(['texTorque','texCorrente','texTemperatura'][i]);
      const ctx = dst.getContext('2d');
      ctx.clearRect(0,0,dst.width,dst.height);
      ctx.drawImage(src, 0, 0);
    });
  }

  // Cria a âncora e insere os planos/texto
  function buildAnchor(targetIndex, motorNome){
    const scene = document.querySelector('a-scene');
    const anchor = document.createElement('a-entity');
    anchor.setAttribute('mindar-image-target', `targetIndex: ${targetIndex}`);

    // Planos com as texturas (ajuste posição/escala conforme sua preferência)
    const planeTorque = document.createElement('a-plane');
    planeTorque.setAttribute('position', '-0.6 0.3 0');
    planeTorque.setAttribute('width', '0.7');
    planeTorque.setAttribute('height', '0.7');
    planeTorque.setAttribute('material', 'src: #texTorque; transparent: true');

    const planeCorrente = document.createElement('a-plane');
    planeCorrente.setAttribute('position', '0.6 0.3 0');
    planeCorrente.setAttribute('width', '0.7');
    planeCorrente.setAttribute('height', '0.7');
    planeCorrente.setAttribute('material', 'src: #texCorrente; transparent: true');

    const planeTemperatura = document.createElement('a-plane');
    planeTemperatura.setAttribute('position', '0  -0.4 0');
    planeTemperatura.setAttribute('width', '0.7');
    planeTemperatura.setAttribute('height', '0.7');
    planeTemperatura.setAttribute('material', 'src: #texTemperatura; transparent: true');

    const title = document.createElement('a-text');
    title.setAttribute('value', motorNome);
    title.setAttribute('color', '#0051A2');
    title.setAttribute('align', 'center');
    title.setAttribute('position', '0 0.85 0');
    title.setAttribute('scale', '1.4 1.4 1');

    anchor.appendChild(title);
    anchor.appendChild(planeTorque);
    anchor.appendChild(planeCorrente);
    anchor.appendChild(planeTemperatura);

    scene.appendChild(anchor);
  }

  // ======= INICIALIZAÇÃO =======
  document.addEventListener('DOMContentLoaded', async () => {
    try {
      const motorId = getParam('motor');
      if(!motorId) throw new Error('Parâmetro ?motor= ausente na URL.');
      const targetIndex = TARGET_INDEX_MAP[motorId];
      if(targetIndex === undefined) throw new Error('Motor não mapeado para targetIndex.');

      const gauges = createGauges();

      const data = await fetchSheetRow(motorId);
      updateGauges(gauges, data);
      mirrorCanvasesToAssets();
      buildAnchor(targetIndex, data.nome);

      // Oculta loader
      document.querySelector('.arjs-loader').style.display = 'none';

      // Atualizações periódicas (ex.: a cada 10 s)
      setInterval(async () => {
        const d = await fetchSheetRow(motorId);
        updateGauges(gauges, d);
        mirrorCanvasesToAssets();
      }, 10000);

    } catch (err) {
      alert('Erro: ' + err.message);
      console.error(err);
    }
  });
})();
</script>

</body>
</html>
